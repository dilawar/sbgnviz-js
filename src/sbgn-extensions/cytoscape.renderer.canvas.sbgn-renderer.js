(function ($$) {
    var sbgnShapes = $$.sbgnShapes = {
        'source and sink': true,
        'nucleic acid feature': true,
        'complex': true,
        'dissociation': true
    };

    $$.sbgn = {
    };

    $$.sbgn.colors = {
        clone: "#a9a9a9",
        association: "#6B6B6B",
        port: "#6B6B6B"
    };

    $$.sbgn.drawEllipsePath = function (context, x, y, width, height) {
        window.cyNodeShapes['ellipse'].drawPath(context, x, y, width, height);
    };

    $$.sbgn.drawNucAcidFeature = function (context, width, height,
            centerX, centerY, cornerRadius) {
        var halfWidth = width / 2;
        var halfHeight = height / 2;

        context.translate(centerX, centerY);
        context.beginPath();

        context.moveTo(-halfWidth, -halfHeight);
        context.lineTo(halfWidth, -halfHeight);
        context.lineTo(halfWidth, 0);
        context.arcTo(halfWidth, halfHeight, 0, halfHeight, cornerRadius);
        context.arcTo(-halfWidth, halfHeight, -halfWidth, 0, cornerRadius);
        context.lineTo(-halfWidth, -halfHeight);

        context.closePath();
        context.translate(-centerX, -centerY);
        context.fill();
    };

    $$.sbgn.isMultimer = function (node) {
        var sbgnClass = node._private.data.sbgnclass;
        if (sbgnClass.indexOf("multimer") != -1)
            return true;
        return false;
    };

    //this function is created to have same corner length when
    //complex's width or height is changed
    $$.sbgn.generateComplexShapePoints = function (cornerLength, width, height) {
        //cp stands for corner proportion
        var cpX = cornerLength / width;
        var cpY = cornerLength / height;

        var complexPoints = [-1 + cpX, -1, -1, -1 + cpY, -1, 1 - cpY, -1 + cpX,
            1, 1 - cpX, 1, 1, 1 - cpY, 1, -1 + cpY, 1 - cpX, -1];

        return complexPoints;
    };

    $$.sbgn.drawPortsToEllipseShape = function (context, node) {
        var width = node.width();
        var height = node.height();
        var centerX = node._private.position.x;
        var centerY = node._private.position.y;
        var padding = node._private.style['border-width'].pxValue / 2;

        for (var i = 0; i < node._private.data.ports.length; i++) {
            var port = node._private.data.ports[i];
            var portX = port.x + centerX;
            var portY = port.y + centerY;
            var closestPoint = $$.math.intersectLineEllipse(
                    portX, portY, centerX, centerY, width / 2, height / 2);
            context.moveTo(portX, portY);
            context.lineTo(closestPoint[0], closestPoint[1]);
            context.stroke();

            //add a little black circle to ports
            var oldStyle = context.fillStyle;
            context.fillStyle = $$.sbgn.colors.port;
            $$.sbgn.drawEllipse(context, portX, portY, 2, 2);
            context.fillStyle = oldStyle;
            context.stroke();
        }
    };

    window.cyStyfn.types.nodeShape.enums.push('source and sink');
    window.cyStyfn.types.nodeShape.enums.push('nucleic acid feature');
    window.cyStyfn.types.nodeShape.enums.push('complex');
    window.cyStyfn.types.nodeShape.enums.push('dissociation');

    $$.sbgn.registerSbgnShapes = function () {
        window.cyNodeShapes["dissociation"] = {
            draw: function (context, node) {
                var centerX = node._private.position.x;
                var centerY = node._private.position.y;

                var width = node.width();
                var height = node.height();

                context.beginPath();
                context.translate(centerX, centerY);
                context.scale(width / 4, height / 4);

                // At origin, radius 1, 0 to 2pi
                context.arc(0, 0, 1, 0, Math.PI * 2 * 0.999, false); // *0.999 b/c chrome rendering bug on full circle

                context.closePath();
                context.scale(4 / width, 4 / height);
                context.translate(-centerX, -centerY);

                $$.sbgn.drawEllipse(context, centerX, centerY, width / 2, height / 2);

                context.stroke();

                $$.sbgn.drawEllipse(context, centerX, centerY, width, height);

                context.stroke();

                context.fill();

                $$.sbgn.drawPortsToEllipseShape(context, node);

            },
            drawPath: function (context, node) {

            },
            intersectLine: window.cyNodeShapes["ellipse"].intersectLine,
            intersectBox: window.cyNodeShapes["ellipse"].intersectBox,
            checkPoint: window.cyNodeShapes["ellipse"].checkPoint
        };
//        window.cyNodeShapes["complex"] = {
//            points: [],
//            multimerPadding: 5,
//            cornerLength: 12,
//            draw: function (context, node) {
//                var width = node.width();
//                var height = node.height();
//                var centerX = node._private.position.x;
//                var centerY = node._private.position.y;
//                var stateAndInfos = node._private.data.sbgnstatesandinfos;
//                var label = node._private.data.sbgnlabel;
//                var cornerLength = cyNodeShapes["complex"].cornerLength;
//                var multimerPadding = cyNodeShapes["complex"].multimerPadding;
//                var cloneMarker = node._private.data.sbgnclonemarker;
//
//                window.cyNodeShapes["complex"].points = $$.sbgn.generateComplexShapePoints(cornerLength,
//                        width, height);
//
//                //check whether sbgn class includes multimer substring or not
//                if ($$.sbgn.isMultimer(node)) {
//                    //add multimer shape
//                    window.cyRenderer.drawPolygonPath(context,
//                            centerX + multimerPadding, centerY + multimerPadding,
//                            width, height, window.cyNodeShapes["complex"].points);
//                    context.fill();
//                    context.stroke();
//
//                    $$.sbgn.cloneMarker.complex(context,
//                            centerX + multimerPadding, centerY + multimerPadding,
//                            width, height, cornerLength, cloneMarker, true,
//                            node._private.style['background-opacity'].value);
//
//                    //context.stroke();
//                }
//
//                window.cyRenderer.drawPolygonPath(context,
//                        centerX, centerY,
//                        width, height, cyNodeShapes["complex"].points);
//
//                context.fill();
//                context.stroke();
//
//                $$.sbgn.cloneMarker.complex(context, centerX, centerY,
//                        width, height, cornerLength, cloneMarker, false,
//                        node._private.style['background-opacity'].value);
//
////                $$.sbgn.forceOpacityToOne(node, context);
////                $$.sbgn.drawComplexStateAndInfo(context, node, stateAndInfos, centerX, centerY, width, height);
//
//            },
//            drawPath: function (context, node) {
//            },
//            intersectLine: window.cyNodeShapes["roundrectangle"].intersectLine,
//            intersectBox: window.cyNodeShapes["roundrectangle"].intersectBox,
//            checkPoint: window.cyNodeShapes["roundrectangle"].checkPoint
//        };

        window.cyNodeShapes["nucleic acid feature"] = {
            points: window.cyMath.generateUnitNgonPointsFitToSquare(4, 0),
            multimerPadding: 5,
            draw: function (context, node) {
                var centerX = node._private.position.x;
                var centerY = node._private.position.y;
                ;
                var width = node.width();
                var height = node.height();
                var label = node._private.data.sbgnlabel;
                var cornerRadius = window.cyMath.getRoundRectangleRadius(width, height);
                var multimerPadding = window.cyNodeShapes["nucleic acid feature"].multimerPadding;
                var cloneMarker = node._private.data.sbgnclonemarker;

                //check whether sbgn class includes multimer substring or not
                if ($$.sbgn.isMultimer(node)) {
                    //add multimer shape
                    $$.sbgn.drawNucAcidFeature(context, width, height,
                            centerX + multimerPadding,
                            centerY + multimerPadding, cornerRadius);

                    context.stroke();

                    $$.sbgn.cloneMarker.nucleicAcidFeature(context,
                            centerX + multimerPadding, centerY + multimerPadding,
                            width, height, cloneMarker, true,
                            node._private.style['background-opacity'].value);

                    //context.stroke();
                }

                $$.sbgn.drawNucAcidFeature(context, width, height, centerX,
                        centerY, cornerRadius);

                context.stroke();

                $$.sbgn.cloneMarker.nucleicAcidFeature(context, centerX, centerY,
                        width, height, cloneMarker, false,
                        node._private.style['background-opacity'].value);

//                var nodeProp = {'label': label, 'centerX': centerX, 'centerY': centerY,
//                    'opacity': node._private.style['text-opacity'].value, 'width': node.width(), 'height': node.height()};
//
//                $$.sbgn.drawDynamicLabelText(context, nodeProp);
//                $$.sbgn.forceOpacityToOne(node, context);
//                $$.sbgn.drawStateAndInfos(node, context, centerX, centerY);
            },
            drawPath: function (context, node) {

            },
            intersectLine: window.cyNodeShapes["roundrectangle"].intersectLine,
            intersectBox: window.cyNodeShapes["roundrectangle"].intersectBox,
            checkPoint: window.cyNodeShapes["roundrectangle"].checkPoint
        };
        window.cyNodeShapes["source and sink"] = {
            points: window.cyMath.generateUnitNgonPoints(4, 0),
            draw: function (context, node) {
                var centerX = node._private.position.x;
                var centerY = node._private.position.y;

                var width = node.width();
                var height = node.height();
                var label = node._private.data.sbgnlabel;
                var pts = window.cyNodeShapes["source and sink"].points;
                var cloneMarker = node._private.data.sbgnclonemarker;

                $$.sbgn.drawEllipse(context, centerX, centerY,
                        width, height);

                context.stroke();

                context.beginPath();
                context.translate(centerX, centerY);
                context.scale(width * Math.sqrt(2) / 2, height * Math.sqrt(2) / 2);

                context.moveTo(pts[2], pts[3]);
                context.lineTo(pts[6], pts[7]);
                context.closePath();

                context.scale(2 / (width * Math.sqrt(2)), 2 / (height * Math.sqrt(2)));
                context.translate(-centerX, -centerY);

                context.stroke();

                $$.sbgn.cloneMarker.sourceAndSink(context, centerX, centerY,
                        width, height, cloneMarker,
                        node._private.style['background-opacity'].value);

            },
            drawPath: function (context, node) {
            },
            intersectLine: window.cyNodeShapes["ellipse"].intersectLine,
            intersectBox: window.cyNodeShapes["ellipse"].intersectBox,
            checkPoint: window.cyNodeShapes["ellipse"].checkPoint
        };
    };

    $$.sbgn.drawEllipse = function (context, x, y, width, height) {
        //$$.sbgn.drawEllipsePath(context, x, y, width, height);
        //context.fill();
        window.cyNodeShapes['ellipse'].draw(context, x, y, width, height);
    };

    $$.sbgn.cloneMarker = {
        unspecifiedEntity: function (context, centerX, centerY,
                width, height, cloneMarker, opacity) {
            if (cloneMarker != null) {
                var oldGlobalAlpha = context.globalAlpha;
                context.globalAlpha = opacity;
                var oldStyle = context.fillStyle;
                context.fillStyle = $$.sbgn.colors.clone;

                context.beginPath();
                context.translate(centerX, centerY);
                context.scale(width / 2, height / 2);

                var markerBeginX = -1 * Math.sin(Math.PI / 3);
                var markerBeginY = Math.cos(Math.PI / 3);
                var markerEndX = 1 * Math.sin(Math.PI / 3);
                var markerEndY = markerBeginY;

                context.moveTo(markerBeginX, markerBeginY);
                context.lineTo(markerEndX, markerEndY);
                context.arc(0, 0, 1, Math.PI / 6, 5 * Math.PI / 6);

                context.scale(2 / width, 2 / height);
                context.translate(-centerX, -centerY);
                context.closePath();

                context.fill();
                context.fillStyle = oldStyle;
                context.globalAlpha = oldGlobalAlpha;
            }
        },
        sourceAndSink: function (context, centerX, centerY,
                width, height, cloneMarker, opacity) {
            $$.sbgn.cloneMarker.unspecifiedEntity(context, centerX, centerY,
                    width, height, cloneMarker, opacity);
        },
        simpleChemical: function (context, centerX, centerY,
                width, height, cloneMarker, isMultimer, opacity) {
            if (cloneMarker != null) {
                var cornerRadius = Math.min(width / 2, height / 2);

                var firstCircleCenterX = centerX - width / 2 + cornerRadius;
                var firstCircleCenterY = centerY;
                var secondCircleCenterX = centerX + width / 2 - cornerRadius;
                var secondCircleCenterY = centerY;

                simpleChemicalLeftClone(context, firstCircleCenterX, firstCircleCenterY,
                        2 * cornerRadius, 2 * cornerRadius, cloneMarker, opacity);

                simpleChemicalRightClone(context, secondCircleCenterX, secondCircleCenterY,
                        2 * cornerRadius, 2 * cornerRadius, cloneMarker, opacity);

                var oldStyle = context.fillStyle;
                context.fillStyle = $$.sbgn.colors.clone;
                var oldGlobalAlpha = context.globalAlpha;
                context.globalAlpha = opacity;

                var recPoints = $$.math.generateUnitNgonPointsFitToSquare(4, 0);
                var cloneX = centerX;
                var cloneY = centerY + 3 / 4 * cornerRadius;
                var cloneWidth = width - 2 * cornerRadius;
                var cloneHeight = cornerRadius / 2;

                renderer.drawPolygon(context, cloneX, cloneY, cloneWidth, cloneHeight, recPoints);
                context.fillStyle = oldStyle;
                context.globalAlpha = oldGlobalAlpha;
            }
        },
        perturbingAgent: function (context, centerX, centerY,
                width, height, cloneMarker, opacity) {
            if (cloneMarker != null) {
                var cloneWidth = width;
                var cloneHeight = height / 4;
                var cloneX = centerX;
                var cloneY = centerY + height / 2 - height / 8;

                var markerPoints = [-5 / 6, -1, 5 / 6, -1, 1, 1, -1, 1];

                var oldStyle = context.fillStyle;
                context.fillStyle = $$.sbgn.colors.clone;
                var oldGlobalAlpha = context.globalAlpha;
                context.globalAlpha = opacity;

                renderer.drawPolygon(context,
                        cloneX, cloneY,
                        cloneWidth, cloneHeight, markerPoints);

                context.fill();

                context.fillStyle = oldStyle;
                context.globalAlpha = oldGlobalAlpha;
                //context.stroke();
            }
        },
        nucleicAcidFeature: function (context, centerX, centerY,
                width, height, cloneMarker, isMultimer, opacity) {
            if (cloneMarker != null) {
                var cloneWidth = width;
                var cloneHeight = height / 4;
                var cloneX = centerX;
                var cloneY = centerY + 3 * height / 8;

                var oldStyle = context.fillStyle;
                context.fillStyle = $$.sbgn.colors.clone;
                var oldGlobalAlpha = context.globalAlpha;
                context.globalAlpha = opacity;

                var cornerRadius = window.cyMath.getRoundRectangleRadius(width, height);

                $$.sbgn.drawNucAcidFeature(context, cloneWidth, cloneHeight,
                        cloneX, cloneY, cornerRadius, opacity);

                context.fillStyle = oldStyle;
                context.globalAlpha = oldGlobalAlpha;
                //context.stroke();
            }
        },
        macromolecule: function (context, centerX, centerY,
                width, height, cloneMarker, isMultimer, opacity) {
            $$.sbgn.cloneMarker.nucleicAcidFeature(context, centerX, centerY,
                    width, height, cloneMarker, isMultimer, opacity);
        },
        complex: function (context, centerX, centerY,
                width, height, cornerLength, cloneMarker, isMultimer, opacity) {
            if (cloneMarker != null) {
                var cpX = cornerLength / width;
                var cpY = cornerLength / height;
                var cloneWidth = width;
                var cloneHeight = height * cpY / 2;
                var cloneX = centerX;
                var cloneY = centerY + height / 2 - cloneHeight / 2;

                var markerPoints = [-1, -1, 1, -1, 1 - cpX, 1, -1 + cpX, 1];

                var oldStyle = context.fillStyle;
                context.fillStyle = $$.sbgn.colors.clone;
                var oldGlobalAlpha = context.globalAlpha;
                context.globalAlpha = opacity;

                window.cyRenderer.drawPolygonPath(context,
                        cloneX, cloneY,
                        cloneWidth, cloneHeight, markerPoints);
                context.fill();

                context.fillStyle = oldStyle;
                context.globalAlpha = oldGlobalAlpha;

//                context.stroke();
            }
        }
    };

    $$.sbgn.intersectLinePorts = function (node, x, y, portId) {
        var ports = node._private.data.ports;
        if (ports.length < 0)
            return [];

        var nodeX = node._private.position.x;
        var nodeY = node._private.position.y;
        var width = node.width();
        var height = node.height();
        var padding = node._private.style['border-width'].pxValue / 2;

        for (var i = 0; i < node._private.data.ports.length; i++) {
            var port = node._private.data.ports[i];
            if (portId == port.id) {
                return $$.math.intersectLineEllipse(
                        x, y, port.x + nodeX, port.y + nodeY, 1, 1);
            }
        }
        return [];
    };

//    $$.sbgn.intersetLineSelection = function (render, node, x, y, portId) {
//        //TODO: do it for all classes in sbgn, create a sbgn class array to check
//        if (sbgnShapes[render.getNodeShape(node)]) {
//            return window.cyNodeShapes[render.getNodeShape(node)].intersectLine(
//                    node, x, y, portId);
//        }
//        else {
//            return window.cyNodeShapes[render.getNodeShape(node)].intersectLine(
//                    node._private.position.x,
//                    node._private.position.y,
//                    node.outerWidth(),
//                    node.outerHeight(),
//                    x, //halfPointX,
//                    y, //halfPointY
//                    node._private.style["border-width"].pxValue / 2
//                    );
//        }
//    };


})(cytoscape);